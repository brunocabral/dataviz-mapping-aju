<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="./css/mapping-aju.css" type="text/css">
</head>
<body>
  
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.5.0/lodash.min.js"></script>
    <script src="https://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
  <script type="text/javascript">
    //====================  JSON  DATA ==================================================

    //  STATION EXAMPLE
    // [{
    //     "id": 0,
    //     "nome": "Sao Cristov√£o",
    //     "x": "50",
    //     "y": "900"
    //   }
    // ];

    // BUS LINES EXAMPLE
    // [{
    //   "numeracao": "301",
    //   "nome": "Luiz Alves / Zona Oeste",
    //   "tipo": "Linha Metropolitana",
    //   "terminais": [{
    //     "id": 1
    //   }, {
    //     "id": 2
    //   }]
    // }]

    //=========== Standardizing and preparing input data for dataviz ====================

    var STATIONS = [];
    var LINKS = [];

    //Load json data files
    queue()
      .defer(d3.json, './data/terminais.json')
      .defer(d3.json, './data/linhas_itinerario.json')
      .await(renderMap);

    function renderMap(error, stationData, busRouteData) {

      //== NODES - Initiate input data of Bus Stations
      function initStationData() {
        var stations = []; //temp
        for (var i = 0; i < stationData.length; i++) {
          //transforms a JSON object into a Station object
          var station = new Station(
            stationData[i]["id"],
            stationData[i]["nome"],
            stationData[i]["x"],
            stationData[i]["y"]);
          stations.push(station);
        }
        return stations;
      }

      STATIONS = initStationData();

      //== LINKS - Initiate input data of Bus Lines routes links (connections) ============
      function initLinkData() {
        var links = []; //temp 

        for (var i = 0; i < busRouteData.length; i++) {
          var stationsVisited = busRouteData[i].terminais; //Bus Stations in which the Bus Route visits

          if (stationsVisited.length > 1) { // minimum 2 Bus Stations to connections exist
            var color = "rgba(" +
              Math.floor(Math.random() * 255) + "," +
              Math.floor(Math.random() * 200) + "," +
              Math.floor(Math.random() * 255) +
              ", 1)";

            for (var j = 0; j < stationsVisited.length - 1; j++) { //-1 to avoid array out of bounds exception
              var source = stationsVisited[j]; //current station
              var target = stationsVisited[j + 1]; //next station 

              var link = {}; //stores all Bus link info
              link.source = source.id;
              link.target = target.id;
              link.busRouteId = busRouteData[i].numeracao.toString();
              link.busRouteName = busRouteData[i].nome;
              link.color = color;
              links.push(link);
            }
          }
        }
        return links;
      }

      LINKS = initLinkData();

      // console.log(stations)
      // console.log(links);

      //Bus Station Class
      function Station(id, name, x, y) {
        this.id = id;
        this.name = name;
        this.fixed = true; //node position fixed on graph
        this.x = x; //positioning x-axis
        this.y = y; //positioning y-axis    
      }

      // == DATA FORMATING  ===============================================================

      /* 
        MULTIPLE LINKS BETWEEN NODES IN FORCE LAYOUT
        Lodash.js lib.
      */
      _.each(LINKS, function (link) {
        // links with: same target + source or source + target 
        var same = _.where(LINKS, {
          'source': link.source,
          'target': link.target
        });
        var sameInverse = _.where(LINKS, {
          'source': link.target,
          'target': link.source
        });
        var sameAll = same.concat(sameInverse);

        _.each(sameAll, function (s, i) {
          s.sameIndex = (i + 1);
          s.sameTotal = sameAll.length;
          s.sameTotalHalf = (s.sameTotal / 2);
          s.sameUneven = ((s.sameTotal % 2) !== 0);
          s.sameMiddleLink = ((s.sameUneven === true) && (Math.ceil(s.sameTotalHalf) === s.sameIndex));
          s.sameLowerHalf = (s.sameIndex <= s.sameTotalHalf);
          s.sameArcDirection = s.sameLowerHalf ? 0 : 1;
          s.sameIndexCorrected = s.sameLowerHalf ? s.sameIndex : (s.sameIndex - Math.ceil(s.sameTotalHalf));
        });
      });

      var maxSame = _.chain(LINKS)
        .sortBy(function (x) {
          return x.sameTotal;
        })
        .last()
        .value().sameTotal;

      _.each(LINKS, function (link) {
        link.maxSameHalf = Math.floor(maxSame / 3);
      });

      // D3 FORCE  SETTINGS
      var width = 900,
        height = 1035;

      var force = d3.layout.force()
        .nodes(STATIONS)
        .links(LINKS)
        .size([width, height])
        .linkDistance(300)
        .charge(-80)
        .on('tick', tick)
        .start();

      // DRAG function
      var drag = force.drag()
        .on("dragstart", dragged);

      // RENDER - SVG
      var svgContainer = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)

      // TOOLTIP - Bus Route info 
      var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      //Paths (Bus Route)
      var path = svgContainer.append("g").selectAll("path")
        .data(force.links())
        .enter().append("path")
        .attr("id", function (d) {
          return d.busRouteId;
        })
        .attr("class", function (d) {
          return "busroute-path " + "busroute-" + d.busRouteId;
        })
        .style("stroke", function (d) {
          return d.color;
        })
        .on("mouseover", peekRouteOn)
        .on("mouseout", peekRouteOff)
        .on("click", showRoute);

      //Circles (Station Nodes)
      var circle = svgContainer.append("g").selectAll("circle")
        .data(force.nodes())
        .enter().append("circle")
        .attr("r", 10)
        .call(drag)
        .on('dblclick', showNeighborStations);

      var text = svgContainer.append("g").selectAll("text")
        .data(force.nodes())
        .enter().append("text")
        .attr("x", 8)
        .attr("y", ".31em")
        .text(function (d) {
          return d.name;
        });

      // GLOWING EFFECT

      //Container for the gradients
      var defs = svgContainer.append("defs");

      //Filter for the outside glow
      var filter = defs.append("filter")
        .attr("id", "glow");
      filter.append("feGaussianBlur")
        .attr("stdDeviation", "3.5")
        .attr("result", "coloredBlur");
      
      var feMerge = filter.append("feMerge");
      feMerge.append("feMergeNode")
        .attr("in", "coloredBlur");
      feMerge.append("feMergeNode")
        .attr("in", "SourceGraphic");
      
      // ==============

      //Glows bus route when hovered on 
      function peekRouteOn(d, i) {
        var coords = d3.mouse(this);
        svgContainer.selectAll(".busroute-" + this.id)
          .style("filter", "url(#glow)");
        
			  //Show Tooltip show tooltip with bus route info
			  tooltip.transition()
				  .duration(200)
				  .style("opacity", .9);

			  var link = LINKS.find(i => i.busRouteId === this.id);
			  tooltip.html(this.id + " " + link.busRouteName)
				  .style("left", (coords[0]) + "px")
				  .style("top", (coords[1] - 28) + "px");
      }

      function peekRouteOff() {
        svgContainer.selectAll(".busroute-path")
          .style("filter", "none");

        //hide tooltip
			  tooltip.transition()
				.duration(300)
				.style("opacity", 0);
      }

      // TICK Interaction
      function tick(d) {
        circle.attr("transform", function (d) {
          return "translate(" + d.x + "," + d.y + ")";
        });
        path.attr("d", linkArc);
        text.attr("transform", function (d) {
          return "translate(" + d.x + "," + d.y + ")";
        });
      }

      // DRAGGED - when node is dragged, its position is fixed
      function dragged(d) {
        d3.select(this).classed("fixed", d.fixed = true);
      }

      // ARC CALCULATION (Between Paths)
      function linkArc(d) {
        var dx = (d.target.x - d.source.x),
          dy = (d.target.y - d.source.y),
          dr = Math.sqrt(dx * dx + dy * dy),
          unevenCorrection = (d.sameUneven ? 0 : 0.3),
          arc = ((dr * d.maxSameHalf) / (d.sameIndexCorrected - unevenCorrection));

        if (d.sameMiddleLink) {
          arc = 0;
        }
        return "M" + d.source.x + "," + d.source.y + "A" + arc + "," + arc + " 0 0," + d.sameArcDirection + " " + d
          .target
          .x + "," + d.target.y;
      }

      // HIGHTLIGHT ENTIRE BUS ROUTE    
      var toggleRoute = 0; //Toggle stores whether the highlighting is on

      function showRoute(d, i) {
        if (toggleRoute == 0) {
          svgContainer.selectAll(".busroute-path")
            .style("opacity", function (d) {
              return 0.1;
            });
          svgContainer.selectAll(".busroute-" + this.id)
            .style("opacity", function (d) {
              return 1;
            });
          toggleRoute = 1
        } else {
          //Reset to default values
          circle.style("opacity", 1);
          path.style("opacity", 1);
          toggleRoute = 0;
        }
      }

      //HIGHLIGHT LINKED NODES (Stations)
      var toggle = 0; //Toggle stores whether the highlighting is on
      var linkedByIndex = {}; //Create an array logging what is connected to what
      for (i = 0; i < force.nodes.length; i++) {
        linkedByIndex[i + "," + i] = 1;
      };

      LINKS.forEach(function (d) {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
      });

      //Checks if a pair are neighbours
      function neighboring(a, b) {
        return linkedByIndex[a.index + "," + b.index];
      }

      function showNeighborStations() {
        if (toggle == 0) {
          //Reduce the opacity of all but the neighbouring nodes
          d = d3.select(this).node().__data__;

          path.style("opacity", function (o) {
            return d.index == o.source.index | d.index == o.target.index ? 1 : 0.1;
          });
          //Reduce the op
          toggle = 1;
        } else {
          //Put them back to opacity=1
          circle.style("opacity", 1);
          path.style("opacity", 1);
          toggle = 0;
        }
      }
    }
    /*
     Thanks credits to:
      Glowing effect:
      - https://www.visualcinnamon.com/2016/06/glow-filter-d3-visualization.html  
      Multiple Links between nodes in force layout:
      - http://bl.ocks.org/thomasdobber/9b78824119136778052f64a967c070e0 - thanks to Thomas Dobber
      Arc Calculation
      - https://stackoverflow.com/questions/11368339/drawing-multiple-edges-between-two-nodes-with-d3
    */
  </script>

</body>

</html>